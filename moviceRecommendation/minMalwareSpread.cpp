#include <vector>

#define method1 1
#define method2 0

class Solution
{
public:
#if method1
    std::vector<std::vector<int>> minMalwareSpread(std::vector<std::vector<int>> &graph)
    {
        std::vector<int> ans[100];
        std::vector<std::vector<int>> res;

        int n = graph.size();
        bool vis[100][100];
        memset(vis, 0, sizeof(vis));

        for(int i = 0; i < n; ++i)
        {
            for(int j = 0; j < graph[i].size(); ++j)
            {
                ans[graph[i][j]].push_back(i);
                vis[i][graph[i][j]] = 1;
            }
        }

        for(int i = 0; i < n; ++i)
        {
            int c[100], v[100];
            memset(v, 0, sizeof(v));
            std::vector<int> tt;
            int user;
            memset(c, 0, sizeof(c));

            for(int j = 0; j < graph[i].size(); ++j)
            {
                for(int k = 0; k < ans[graph[i][j]].size(); ++k)
                {
                    user = ans[graph[i][j]][k];
                    if(user == i)
                    {
                        continue;
                    }

                    for(int l = 0; l < graph[user].size(); ++l)
                    {
                        c[graph[user][l]]++;
                    }
                }
            }

            c[0] = -1;
            for(int j = 0, d = 9999, id = 0; j < 5; ++j, id = 0)
            {
                for(int k = 1; k <= 80; ++k)
                {
                    if(vis[i][k] || !c[k])
                    {
                        continue;
                    }

                    if(d >= c[k] && c[k] > c[id])
                    {
                        if(v[k])
                        {
                            continue;
                        }
                        id = k;
                    }
                }

                if(id)
                {
                    d = c[id];
                    v[id] = 1;
                    tt.push_back(id);
                }
                else
                {
                    break;
                }
            }
            res.push_back(tt);
        }
        return res;
    }
#endif

#if method2
    typedef pair<int, pair<int, int>> Node;
    struct less
    {
        bool operator()(const Node &lhs, const Node &rhs)
        {
            if(lhs.second.first == rhs.second.first)
            {
                if(lhs.second.second == rhs.second.second)
                {
                    return lhs.first < rhs.first;
                }
                else
                {
                    return lhs.second.second > rhs.second.second;
                }
            }

            return lhs.second.first > rhs.second.first;
        }
    };

    std::vector<std::vector<int>> minMalwareSpread(std::vector<std::vector<int>> &graph)
    {
        int n = graph.size();
        std::vector<std::vector<int>> recommends(n);
        for(int u = 0; u < n; ++u)
        {
            unordered_map<int, pair<int, int>> movies;
            for(int v = 0; v < n; ++v)
            {
                if(u == v)
                {
                    continue;
                }
                std::vector<int> common;
                set_intersection(graph[u].begin(), graph[u].end(), graph[v].begin(), graph[v].end(), back_inserter(common));

                if(common.size() == 0)
                {
                    continue;
                }

                std::vector<int> diff;

                set_difference(graph[v].begin(), graph[v].end(), common.begin(), common.end(), back_inserter(diff));

                for(const auto &m : diff)
                {
                    movies[m] = {movies[m].first + 1, movies[m].second + common.size()};
                }
            }

            std::priority_queue<Node, std::vector<Node>, less> freqs, cors;
            for(const auto &m : movies)
            {
                freqs.push(m);
                if(freqs.size() > 5)
                {
                    freqs.pop();
                }
            }

            for(; freqs.size(); freqs.pop())
            {
                cors.push({freqs.top().first, {freqs.top().second.second, freqs.top().second.first}});
            }
            for(; cors.size(); cors.pop())
            {
                recommends[u].push_back(cors.top().first);
            }
            std::reverse(recommends[u].begin(), recommends[u].end());
        }

        return recommends;
    }
#endif
};
